---
layout: post
title: "设计模式怎样解决设计问题"
description: "打开正确的使用设计模式的姿势"
tags: [design, code]
---
设计模式采用多种方法解决面向对象设计中经常碰到的问题。这里给出在面向对象设计中的典型问题以及如果使用设计模式解决它们的方法。
{% highlight markdown %}
> 寻找合适的对象
> 决定对象的粒度
> 指定对象接口
> 描述对象的实现
> 运用复用机制
> 关联运行时刻和编译时刻的结构
> 设计应支持变化
{% endhighlight %}
### 1. 寻找合适的对象
面向对象程序由对象组成，**对象**包括数据和对数据进行操作的过程，过程通常称为**方法**或**操作**。对象在收到**客户**的**请求**（或**消息**）后，执行相应的操作。

客户请求是使用对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被**封装**的，它不能被直接访问，它的表示对于对象外部是不可见的。

面向对象设计最困难的部分是**将系统分解成对象集合**。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等等，它们都影响着系统的分解，并且这些因素通常还是相互冲突的。

面向对象设计方法学支持许多设计方法。你可以写出一个问题描述，挑出名词和动词，进行创建相应的类和操作；或者，你可以关注于系统的协作和职责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中。至于哪一种方法最好，并无定论。

设计的许多对象来源于现实世界的分析模型。但是，设计结构所得到的类通常在现实是家中并不存在，有些是像数组之类的低层类，而另一些则层次较高。例如，*Composite*模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反映当前现实世界的模型并不能产生也能反映将来世界的系统。设计中的抽象对于产生灵活的设计是至关重要的。

设计模式帮你确定不明显的抽象和描述这些抽象的对象。例如，描述过程或算法的对象现实并不存在，但它们却是设计的关键部分。*Strategy*模式描述了怎样实现可互换的算法族。*State*模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期都并不存在，后来为使设计更灵活、复用性更好才将它们发掘出来。

### 2. 决定对象的粒度
对象在大小和数目上的变化极大。它们能表示下自硬件或上自整个应用的任何事物。那么我们怎样决定一个对象应该是什么？

设计模式很好地讲述了这个问题。*Facade*模式描述了怎样对对象表示完整的子系统，*Flyweight*模式描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。*Abstract Factory*和*Builder*产生哪些专门负责生成其他对象的对象。*Visitor*和*Command*生成的对象专门负责实现对其他对象或对象组的请求。

### 3. 指定对象接口
对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的**型构（signature）**。对象操作所定义的所有操作型构的集合被称为该对象的**接口（interface）**。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可发送给该对象。
**类型（type）**是用来标识特定接口的一个名字。如果一个对象接受“Window”接口所定义的所有操作请求，那么我们就说该对象具有“Window”类型。一个对象可以有许多类型，并且不同的对象可以共享同一个类型。对象接口的某部分可以用某个类型来刻画，而其他部分则可用其他类型刻画。两个类型相同的对象只需要共享它们的部分接口。接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的**子类型（subtype）**，另一个类型称之为它的**超类型（supertype）**。我们常说子类型*继承了它的超类型的接口。

在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能与外部交流，如果不通过对象的接口就无法知道对象的任何事情，也无法请求对象做任何事情。对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现。

当给对象发送请求时，所引起的具体操作既可以与请求本身有关又与接收对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为**动态绑定（dynamic binding）**。

动态绑定是指发送的请求直到运行时刻才受你具体的实现的约束。因而，在直到任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为**多态（polymorphism）**，它是面向对象系统的核心概念之一。多态允许客户对象仅要求其他对象支持特定接口，除此之外对其假设几近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在运行时刻动态改变它们相互的关系。

设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。设计模式也许还会告诉你接口中不应包括哪些东西。*Memento*模式是一个很好的例子，它描述了怎样封装和保存对象内部的状态，以便一段时间后对象能恢复到这一状态。它规定了Memento对象必须定义两个接口：一个允许客户保持和复制Memento的限制接口，和一个只有原对象才能使用的用来存储和提取Memento中状态的特权接口。

设计模式也指定了接口之间的关系。特别地，它们经常要求一个类具有相似的接口；或它们对一些类的接口做了限制。例如，Decorator和Proxy模式要Decorator和Proxy对象的接口与被修饰的对象和受委托的对象一致。而Visitor模式中，Visitor接口必须反映出visitor能访问的对象的所有类。

### 4. 描述对象的实现
我们很少提及到实际上怎么去定义一个对象。对象的实现是由它的**类**决定的，类指定了对象的内部数据和表示，也定义了对象所能完成的操作。

对象通过**实例化**类来创建，此对象被称为该类的**实例**。当实例化类时，要给对象的内部数据（由**实例变量**组成）分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类创建的。

新的类可以由已存在的类通过**类继承（class inheritance）**来定义。当**子类（subclass）**继承**父类（parent class）**时，子类包含了父类定义的所有数据和操作。子类的实例对象包含所有子类和父类定义的数据，且它们能完成子类和父类定义的所有操作。

**抽象类（abstract class）**的主要目的是为了它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为**抽象操作（abstract operation）。非抽象类称为**具体类（concrete class）**。

子类能够改进和抽芯定义它们父类的操作。更具体地说，类能够**重定义（override）**父类定义的操作，重定义使得子类能够接管父类对请求的处理操作。类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易的定义具有相近功能的对象族。

* 类继承与接口继承的比较

  理解对象的类（class）与对象的类型（type）之间的差别非常重要。一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。

  当然，对象的类和类型是有紧密关系的。因为类定义了对象所能执行的操作，也定义了对象的类型。当我们说一个对象是一个类的实例时，即指该对象支持类所定义的接口。

  理解类继承和接口继承（或子类型化）之间的差别十分重要。类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。然而，接口继承（或子类型化）描述了一个对象什么时候能被用来替代另一个对象。尽管大部分程序设计语言并不区分接口继承和实现继承的差别，但使用中人们还是分别对待它们。很多设计模式依赖于这种差别。例如：Chain of Responsibility模式中的对象必须有一个公共的类型，但一般情况下它们不具有公共的实现。在Composite模式中，构件定义了一个公共的接口，但是Composite通常定义一个公共的实现。Command、Observer、State、Strategy通常纯粹作为接口的抽象类实现。

* 对接口编程，而不是对实现编程

  类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象快速定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现。

  然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的（通常可以从抽象类来继承）。为什么？因为多态依赖于这种能力。

  当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。

  只根据抽象类中定义的接口来操作对象有以下来个好处：
  1）客户无需知道他们使用对象的特定类型，只需对象有客户所期望的接口。
  2）客户无须知道他们使用的对象是用什么类来实现的，他们只需知道定义接口的抽象类。
  这将极大地坚守子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：**针对接口编程，而不是针对实现编程**。

当你不得不在系统的某个地方实例化具体的类（即指定一个特定的实现）时，创建性模式（Abstract Factory，Builder，Factory Method，Prototype，和Singleton)可以帮你。通过抽象对象的创建过程，这些模式提供不同方式以在实例化时建立接口和实现的透明连接。创建型模式确保你的系统是采用针对接口的方式书写的，而不是针对实现而书写的。

### 5. 运用复用机制
理解对象、接口、类和继承之类的概念对大多数人来说并不难，问题的关键在于如何运用它们写出灵活的、可复用的软件。设计模式将告诉你怎样去做。

#### 5.1 继承和组合的比较
面向对象系统中功能复用的两种最常用技术是类继承和**对象组合（object composition）**。正如我们已解释过的，类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为**白箱复用（white-box reuse）**。术语“白箱”是相对可视性而言：在继续方式中，父类的内部细节对子类可见。

对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或者组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为**黑箱复用（black-box reuse）**，因为对象的内部细节是不可见的。对象只是以“黑箱”的形式出现。

继承和组合各有优缺点。类继承是在编译时刻静态定义的，且可以直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作。

但是类继承也有一些不足之处。*首先*，因为继承在编译时刻就定义了，所以无法再运行时刻改变从父类继承的实现。*更糟的是*，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性”。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。

当你需要复用子类时，实现上的依赖性就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决方法就是只继承抽象类，因为抽象类提供较少的实现。

对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还好产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。

对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小的规模，并且不太可能增长为不可控的庞然大物。另一方面，基于对象组合的设计会有更多的对象（而有较少的类），且系统的行为将依赖于对象间的关系而不是被定义在某个类中。这导出了我们的面向对象设计的第二个原则：**优先使用对象组合，而不是类继承**。

理想情况下，你不应为获得复用而去创建新的构建。你应该能够只使用对象组合技术，通过组装已有的构件就能获得你需要的功能。但是事实很少如此，因为可用构件的集合实际上并不足够丰富。使得继承的复用使得创建新的构件要比组装旧的构件来得容易。这样，继承和对象组合常一起使用。然后，我们的经验表明：设计者往往过度使用了继承这种复用技术。但依赖于对象组合技术的设计却有更好的复用性（或更简单）。你会看到设计模式中一再使用对象组合技术。

#### 5.2 委托
**委托（delegation）**是一种组合方法，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给他的**代理者（delegate）**。这类似于子类将请求交给它的父类处理。使用继承时，被继承的操作总能引用接受请求的对象。委托方式为了得到同样的效果，接受请求的对象将自己传给被委托人（代理人），使被委托的操作可以引用接受请求的对象。

委托的主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。假定矩形对象和圆对象有相同的类型，我们只需简单的用圆对象替换矩形对象，则得到的窗口就是圆形的。

委托与那些通过对象组合以取得软件灵活性的技术一样，具有如下不足之处：动态的、高度参数化的软件比静态软件更难于理解。还有运行低效问题，不过从长远来看人的低效才是更主要的。只有当委托使设计比较简单而不是更复杂时，它才是好的选择。要给出一个能确切告诉你什么时候可以使用委托的规则是很困难的。因为委托可以得到更好的效率是与上下文有关，并且还依赖于你的经验。委托最适合于符合特定程式的情形，即标准模式的情形。

有一些模式使用了委托，如State、Strategy、和Visitor。在State模式中，一个对象将请求委托给一个描述当前状态的State对象来处理。在Strategy模式中，一个对象将一个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但它对不同的请求有许多策略。这两个模式的目的都是通过改变受托对象来改变委托对象的行为。在Visitor中，对象结构的每个元素上的操作总是被委托到Visitor对象。

其他模式则没有这个多地用到委托。Mediator引用了一个中介其他对象间通信的对象。有时，Mediator对象只是简单地将请求转发给其他对象；有时，它沿着指向自己的引用来传递请求，使用真正意义的委托。Chain of Responsibility通过将请求沿着对象链传递来处理请求，有时，这个请求本身带有一个接受请求对象的引用，这时该模式就使用了委托。Bridge将实现和抽象分离开，如果抽象和一个特定实现非常匹配，那么这个实现可以代理抽象的操作。

委托使对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。

#### 5.3 继承和参数化类型的比较
另一种功能复用技术（并非严格的面向对象技术）是**参数化类型（parameterized type）**，也就是**类属（generic）**或**模板（templates）**。它允许你在定义一个类型时并不指定该类型所用的其他所有类型。未经指定的类型在使用时以*参数*形式提供。例如，一个列表类能够以它所包含元素的类型来进行参数化。如果你想声明一个Integer列表，只需将Integer类型作为列表参数化类型的参数值；声明一个String列表，只需提供String类型作为参数值。语言的实现将会为各种元素类型创建相应的列表类模板的定制版本。

参数化类型给我们提供除了类继承和对象组合外的第三种方法来组合面向对象系统中的行为。许多设计可以使用这三种技术中的任何一种来实现。实现一个以元素比较操作为可变元的排序例程，可有如下方法：
* 1）通过子类实现该操作（Template Method的一个应用）。
* 2）实现为传给排序例程的对象职责（Strategy）。
* 3）作为C++模板或Ada类属的参数，以指定元素比较操作的名称。

这些技术存在着极大的不同之处。对象组合技术允许你在运行时候改变被组合的行为，但是它存在间接性，比较低效。继承允许你提供操作的缺省实现，并通过子类重定义这些操作。参数化类型允许你改变所用到的类型。但是继承和参数化类型都不能在运行时刻改变。哪一种方法最佳，取决于你设计和实现的约束条件。

### 6. 关联运行时刻和编译时刻的结构
### 7. 设计应支持变化














