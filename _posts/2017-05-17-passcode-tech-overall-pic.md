---
layout: post
title: "密码技术 - 环游密码世界"
description: "安全技术的核心竞争力"
tags: [security, cryptography]
---

* 目录
{:toc}

## 1. 密码
### 1.1 Alice与Bob

| 名称 | 角色 | 说明 |
| :------: | :------: | :------: |
| Alice | 女主角 | 通信的一方 |
| Bob | 男主角 | 通信的一方 |
| Eve | 窃听者 | 可窃听通信的内容 |
| Mallory | 攻击者 | 可妨碍通信、伪造消息等 |
| Trent | 第三方 | 可信的第三方 |
| Victor | 验证者 | 证实一项事情是否有实际进行 |

### 1.2 发送者、接受者和窃听者
{% include image.html path="documentation/cryptography/send-receiver-eavasdropper.png" path-detail="documentation/cryptography/send-receiver-eavasdropper.png" alt="send-receiver-eavasdropper" %}

### 1.3 加密与解密
{% include image.html path="documentation/cryptography/encrypt-decrypt.png" path-detail="documentation/cryptography/encrypt-decrypt.png" alt="encrypt-decrypt" %}

### 1.4 密码保证了消息的机密性
在上述场景中，Alice将邮件进行加密，而Bob则进行解密，这样做的目的，是为了不让窃听者Eva读取邮件中的内容。Alice与Bob通过运用密码技术，保证了邮件的**机密性**。

### 1.5 破译
正当的接受者将密文还原成明文称为“解密”，但接受者以外的其他人试图将密文还原为明文，则称为**密码破译（cryptanalysis)**,简称**破译**，有时也称为**密码分析**。

进行破译的人称为**破译者（cryptanalyzer)**。破译者并不一定是坏人，密码学研究者为了研究密码强度（即破译密码的困难程度），也经常需要对密码进行破译。

## 2. 对称密码与公钥密码
### 2.1 密码算法
用于解决复杂问题的步骤，通常称为**算法**。从明文生成密文的步骤，也就是加密的步骤，称为“加密算法”，而解密的步骤则称为“解密算法”。加密、解密的算法合在一起统称为**密码算法**。

### 2.2 密钥
密码算法中需要**密钥**。现实世界中的“钥”，是像🔑这样形状微妙而复杂的金属片。然而，密码算法中的密钥，则是像20345778083277859859425485400566275485458205这样的一串非常大的数字。

无论是在加密还是在解密时，都需要知道密钥。

### 2.3 对称密码与公钥密码
根据密钥的使用方法，可以将密码分为对称密码和公钥密码两种。
* **对称密码**是指在加密和解密时使用同一密钥的方式
* **公钥密码**则是指在加密和解密时使用不同密钥的方式，也称为**非对称密码**。

{% include image.html path="documentation/cryptography/asym-sym-cryptography.png" path-detail="documentation/cryptography/asym-sym-cryptography.png" alt="asym-sym-cryptography" %}

### 2.4 混合密码系统
将对称密码和公钥密码结合起来的密码方式称为**混合密码系统**，这种系统结合了对称密码和公钥密码两者的优势。

## 3. 其他的密码技术
密码技术所提供的并不仅仅是基于密码的机密性，用于检测消息是否被篡改的完整性以及用于确认对方是否是本人的认证都是密码技术的重要部分。

### 3.1 单项散列函数
我们想象一下通过互联网下载免费软件的场景。我们所下载的软件，是否和软件的作者所制作的东西一模一样？会不会有坏人在软件里植入了一些恶意程序呢？

为了防止软件被篡改，有安全意识的软件发布者会在发布软件的同时发布该软件的**散列值**。散列值就是用**单向散列函数**计算出来的数值。

下载该软件的人可以自行计算所下载文件的散列值，然后与软件发布者公布的散列值进行对比。如果两个散列值一致，就说明下载的文件与发布者所发布的文件是相同的。

单向散列函数所保证的并不是机密性，而是**完整性**。完整性指的是“数据是正牌的而不是伪造的”这一性质。使用单向散列函数，就可以检测出数据是否被**篡改**过。

### 3.2 消息认证码
为了确认消息是否来自所期望的通信对象，可以使用**消息认证码**技术。

通过使用消息认证码，不但能够确认消息是否被篡改，而且能够确认消息是否来自所期待的通信对象。也就是说，消息认证码不仅能够保证完整性，还能够提供**认证**机制。

### 3.3 数字签名
Bob刚刚收到一封来自Alice的邮件，内容是“以100万元的价格购买该商品”。

不过，这封邮件到底是不是Alice本人写的呢？Bob仅通过阅读邮件内容，是否能够判断该邮件确实来自Alice呢？邮件的发送者（From：一栏的内容）很容易被伪装，因此确实存在别人**伪装**成Alice的风险。

假设Alice真的发出过邮件，但是Alice当初写的内容真的是“以100万元的价格购买该商品”吗？是否存在这样一种风险，即Alice原本写的是“1万元”，而在邮件传输的过程中被某些别有用心的人进行了**篡改**，将1万元改成了100万元呢？

反过来说，还有这样一种风险，即Alice真的向Bob发送了内容为“以100万元的价格购买该商品”的邮件，但后来Alice又不想买了，于是便谎称“我当初根本没有发过那封邮件”。像这样事后推翻自己先前主张的行为，称为**否认**。

能够防止上述伪装、篡改和否认等威胁的技术，就是**数字签名**。数字签名就是一种将现实世界中的签名和盖章移植到数字世界中的技术，它也是一种重要的密码技术。

### 3.4 伪随机数生成器
**伪随机数生成器**是一种能够模拟产生随机数列的算法。随机数和密码技术有关，这样说大家可能会感到意外，但实际上随机数确实承担着**密钥生成**的重要职责。例如在Web中进行SSL/TLS通信时，会生成一个仅用于当前通信的临时密钥（会话密钥），这个密钥就是基于伪随机数生成器生成的。如果生成随机数的算法不好，窃听者就能够推测出密钥，从而带来通信机密性下降的风险。

## 4. 密码学家的工具箱
{% include image.html path="documentation/cryptography/cryptographer-toolkit.png" path-detail="documentation/cryptography/cryptographer-toolkit.png" alt="cryptographer-toolkit" %}

## 5. 密码与信息安全常识
* 不要使用保密的密码算法
    - 密码算法的秘密早晚会公诸于世
    - 开发高强度的密码算法是非常困难的
* 使用低强度的密码比不进行任何加密更危险
* 任何密码总有一天都会被破解
* 密码只是信息安全的一部分
