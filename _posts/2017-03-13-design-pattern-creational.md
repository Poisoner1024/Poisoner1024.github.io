---
layout: post
title: "设计模式 - 创建型模式"
description: "抽象了实例化的过程"
tags: [design, code]
---

### 设计模式分类

设计模式在粒度和抽象层次上各不相同。我们可以根据两条准则对模式进行分类。第一是**目的**准则，即模式是用来完成什么工作的。模式依据其目的可以分为**创建型（Creational）、结构型（Structural)、行为型（Bahavioral)**三种。创建型模式与对象的创建有关；结构型模式处理类或者对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。第二是**范围**准则，指定模式主要是用于类还是用于对象。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。从某种意义上来说，几乎所有模式都使用继承机制，所以“类模式”只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴。

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的任务。

### 创建型模式
创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

随着系统演化得越来越依赖于对象复合而不是类继承，创建型模式变得更为重要。当这种情况发生时，重心从一组固定行为的硬编码（hard-coding)转移为定义一个较小的行为集，这些行为可以被组合成任意数目的更复杂的行为。这样创建有特定行为 的对象要求的不仅仅是实例化一个类。

在这些模式中有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些具体的类的信息封装起来。第二，它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此，创建型模式在*什么*被创建，*谁*创建它，它是*怎样*被创建的，以及*何时*创建这些方面给予你很大的灵活性。它们允许你用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的（即在编译时指定），也可以是动态的（在运行时）。

有时创建型模式是相互竞争的。例如，在有些情况下Prototype或Abstract Factory用起来都很好。而在另外一些情况下它们是互补的：Builder可以使用其他模式去实现某个构建的创建。Prototype可以再它的实现中使用Singleton.

因为创建型模式紧密相关，我们将所有5个模式一起研究以突出它们的相似点和相异点。我们也将举一个通用的例子--为一个电脑游戏创建一个迷宫--来说明它们的实现。这个迷宫和游戏将随着各种模式不同而略有区别。有时这个游戏将仅仅是找到一个迷宫的出口；在这种情况下，游戏者可能仅能见到该迷宫的局部。有时迷宫包括一些要解决的问题和要战胜的危险，并且这些游戏可能会提供已经被探索过的那部分迷宫地图。

我们将忽略许多迷宫中的细节以及一个迷宫游戏中有一个还是多个游戏者。我们仅仅关注迷宫是怎样被创建的。我们将一个迷宫定义为一系列房间，一个房间知道它的邻居；可能的邻居要么是另一个房间，要么是一堵墙，或者是到另一个房间的一扇门。

类Room、Door和Wall定义了我们所有的例子中使用到的构件。我们仅定义这些类中对创建一个迷宫起重要作用的一些部分。

`下图`表示这些类之间的关系：



每个房间有四面，我们使用枚举类型Direction来指定房间的东南西北.
{% highlight markdown %}
public enum Direction {
    North, South, East, West
}
{% endhighlight %}

类MapSite是所有迷宫组件的公共抽象类。为了简化例子，MapSite仅定义了一个操作Enter，它的含义决定于你在进入什么。如果你进入一个房间，那么你的位置会发生改定。如果你试图进入一扇门，那么这两件事情中就有一件会发生：如果门是开着的，你进入另一个房间。如果门是关着的，那么你就会碰壁。Enter为更加复杂的游戏操作提供了一个简单基础。例如，如果你在一个房间中说“向东走”，游戏只能确定直接在东边的是哪一个MapSite并对它调用Enter。特定子类的Enter操作将计算出你的位置是发生改变，还是你会碰壁。在一个真正的游戏中，Enter可以将移动的游戏者对象作为一个参数
{% highlight markdown %}
public abstract class MapSite {
    public abstract void enter();
}
{% endhighlight %}


















































